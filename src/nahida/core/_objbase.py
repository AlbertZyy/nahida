from __future__ import annotations

__all__ = ["UIDMixin", "has_entity", "get_entity", "NameMixin"]


class UIDMixin:
    """Support UID generated by uuid4()."""
    _uid_registry: dict[int, UIDMixin] = {}
    _uid: int | None = None

    def __init__(self, *, uid: int | None = None) -> None:
        self._uid = uid

        if uid is not None:
            if uid in self._uid_registry:
                raise ValueError(f"uid {uid} already exists.")
            self._uid_registry[uid] = self

    @property
    def uid(self) -> int:
        """Get unique ID of the object."""
        if self._uid is None:
            from uuid import uuid4
            self._uid = int(uuid4())
            self._uid_registry[self._uid] = self

        return self._uid


def has_entity(uid: int, type_check: type | None = None, /) -> bool:
    """Check if an entity with the given UID exists.

    When `type_check` is specified, also check if the entity is an instance of
    the given type."""
    if uid in UIDMixin._uid_registry:
        if type_check is None:
            return True
        return isinstance(UIDMixin._uid_registry[uid], type_check)
    return False


def get_entity[T](uid: int, type_guard: type[T], /) -> T:
    """Get an entity by its global UID."""
    obj = UIDMixin._uid_registry.get(uid, None)

    if not obj:
        raise KeyError(f"entity with uid {uid} not found.")

    if not isinstance(obj, type_guard):
        raise TypeError(f"entity with uid {uid} is not an instance of {type_guard.__name__!r}.")

    return obj


class NameMixin:
    """Support unique names for __repr__."""
    _uname: str | None = None

    def __repr__(self) -> str:
        type_name = self.__class__.__name__

        if self._uname:
            return "{}({})".format(type_name, self._uname)

        return super().__repr__()

    @property
    def uname(self):
        if self._uname:
            return self._uname

        return super().__repr__()

    def set_name(self, name: str | None, /):
        self._uname = name
